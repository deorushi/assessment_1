name: CI-CD

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  schedule:
    - cron: "0 2 * * 1" # Mondays 02:00 UTC
  workflow_dispatch:
    inputs:
      target_environment:
        description: "Where to deploy"
        type: choice
        required: true
        default: "staging"
        options: [ "staging", "production" ]
      image_tag:
        description: "Optional custom image tag (defaults to SHA)"
        required: false
        type: string

env:
  APP_NAME: hello-flask
  APP_PORT: 8000
  REGISTRY: docker.io
  IMAGE_NAME: docker.io/${{ secrets.DOCKER_USERNAME }}/hello-flask
  DOCKER_BUILDKIT: "1"

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  packages: write

jobs:
  lint:
    name: Lint
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
      - name: Install tools
        run: |
          python -m pip install --upgrade pip
          pip install flake8
      - name: Run flake8
        run: flake8 app tests

  tests:
    name: Unit Tests (matrix)
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, windows-latest]
        python-version: ["3.10", "3.11"]
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}
      - name: Cache pip
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: pip-${{ runner.os }}-${{ matrix.python-version }}-${{ hashFiles('**/requirements*.txt') }}
          restore-keys: |
            pip-${{ runner.os }}-
      - name: Install deps
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt pytest coverage
      - name: Run tests with coverage
        run: |
          coverage run -m pytest -q
          coverage xml -o coverage.xml
      - name: Upload coverage
        uses: actions/upload-artifact@v4
        with:
          name: coverage-ubuntu-latest-py3.11
          path: coverage.xml

  sonarcloud:
    name: SonarCloud Analysis
    runs-on: ubuntu-latest
    needs: [lint, tests]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download coverage report
        uses: actions/download-artifact@v4
        with:
          name: coverage-ubuntu-latest-py3.11
          path: .

      - name: SonarCloud Scan
        uses: SonarSource/sonarcloud-github-action@v2
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  docker_build_push:
    name: Docker Build & Push
    runs-on: ubuntu-latest
    needs: [lint, tests, sonarcloud]
    if: github.event_name != 'pull_request'
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Login to Docker registry
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.IMAGE_NAME }}
          tags: |
            type=raw,value=${{ inputs.image_tag }}
            type=sha,format=long
            type=raw,value=latest,enable=${{ github.ref == 'refs/heads/main' }}

      - name: Set up Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Expose image tag output
        id: image
        run: |
          echo "tag=${{ fromJSON(steps.meta.outputs.json).tags[0] }}" >> $GITHUB_OUTPUT

  deploy:
    name: Docker Pull & Deploy (via SSH)
    runs-on: ubuntu-latest
    needs: docker_build_push
    if: github.event_name != 'pull_request'
    environment: ${{ inputs.target_environment || 'staging' }}
    steps:
      - name: Select image tag
        id: select
        run: |
          if [ -n "${{ inputs.image_tag }}" ]; then
            echo "IMAGE=${{ env.IMAGE_NAME }}:${{ inputs.image_tag }}" >> $GITHUB_OUTPUT
          else
            echo "IMAGE=${{ env.IMAGE_NAME }}:${{ github.sha }}" >> $GITHUB_OUTPUT
          fi

      - name: Deploy over SSH
        uses: appleboy/ssh-action@v1
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USERNAME }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script_stop: true
          script: |
            set -Eeuo pipefail
            echo "Logging in to Docker..."
            echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin

            echo "Pulling ${{ steps.select.outputs.IMAGE }} ..."
            docker pull "${{ steps.select.outputs.IMAGE }}"

            echo "Stopping old container..."
            docker rm -f ${{ env.APP_NAME }} || true

            echo "Starting new container..."
            docker run -d --name ${{ env.APP_NAME }} \
              -p 80:${{ env.APP_PORT }} \
              -e FLASK_ENV=production \
              "${{ steps.select.outputs.IMAGE }}"

  notify:
    name: Notifications
    runs-on: ubuntu-latest
    if: always()
    needs: [lint, tests, sonarcloud, docker_build_push, deploy]
    steps:
      - name: Compose message
        id: msg
        run: |
          STATUS="SUCCESS"
          for j in lint tests sonarcloud docker_build_push deploy; do
            r="${{ needs[j].result }}"
            [ "$r" = "failure" ] && STATUS="FAILURE"
          done
          echo "status=$STATUS" >> $GITHUB_OUTPUT

      - name: Post to Slack (optional)
        if: ${{ always() && secrets.SLACK_WEBHOOK_URL != '' }}
        run: |
          text="*${{ github.workflow }}* on *${{ github.ref_name }}* â†’ *${{ steps.msg.outputs.status }}*\n\
          Repo: ${{ github.repository }}\n\
          Actor: ${{ github.actor }}\n\
          Run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          payload=$(jq -nc --arg t "$text" '{text: $t}')
          curl -X POST -H 'Content-type: application/json' \
            --data "$payload" \
            ${{ secrets.SLACK_WEBHOOK_URL }}